# Code Generation Guide

This guide explains the templated C++ code generated by the hpp-proto plugin of the Protocol Buffer compiler for any given `.proto` schema file. Generated message types now take a `Traits` template parameter (defaulting to `hpp_proto::default_traits`) that determines the concrete container types used for strings, bytes, repeated fields, maps, and nested-optionals.

## Compiler Invocation

### Compiler Invocation from CMake

Once the hpp-proto package has been added via `find_package` or `FetchContent`, the Protocol Buffer compiler can be invoked using the `protobuf_generate_hpp` function in the following format:

```cmake
protobuf_generate_hpp(
    TARGET <TargetName> 
    [IMPORT_DIRS <dirs>]
    [PROTOC_OUT_DIR <output_dir>]
    [PROTOS <protobuf_files>]
    [PLUGIN_OPTIONS <plugin_options>])
```

- IMPORT_DIRS: Specifies common parent directories for schema files.
- PROTOC_OUT_DIR: Output directory for generated source files. Defaults to CMAKE_CURRENT_BINARY_DIR.
- PROTOS: List of proto schema files. If omitted, then every source file ending in proto of TARGET will be used.
- <a id="plugin-options">PLUGIN_OPTIONS</a>: A comma-separated string forwarded to the protoc-gen-hpp plugin to customize code generation. Options include:
  - `namespace_prefix=`: Specifies a namespace prefix to be added to the generated C++ code in addition to the package namespace. If the specified prefix contains multiple components, they should be separated by a __dot (.)__ instead of double colons (::).
  - `directory_prefix=`:  Prepends a directory to included non-system dependencies.
  - `proto2_explicit_presence=`: For Proto2 only, makes optional scalar fields implicitly present except for specified scopes. This option can be specified multiple times. For example: the option `proto2_explicit_presence=.pkg1.msg1.field1,proto2_explicit_presence=.pkg1.msg2` instructs the code generator that explicit presence is only applicable for the `field1` of `pkg1.msg1` and all fields of `pkg1.msg2`.

## Traits at a Glance

Any generated message that references trait-controlled types appears as:

```cpp
template <typename Traits = ::hpp_proto::default_traits>
struct MessageName { /* ... */ };
```

`Traits` must provide:

| Alias | Purpose |
|-------|---------|
| `Traits::string_t`, `Traits::bytes_t` | Storage for string/bytes fields |
| `Traits::template repeated_t<T>` | Storage for repeated fields |
| `Traits::template map_t<Key, Value>` | Storage for map fields |
| `Traits::template optional_indirect_t<T>` | Holder for recursive optional embedded messages |
| `Traits::unknown_fields_range_t` | Unknown-field preservation policy |

Bundled traits:

- `hpp_proto::default_traits`: owning containers built from the STL.
- `hpp_proto::pmr_traits`: owning containers built from the STL PMR types.
- `hpp_proto::stable_traits`: owning containers with flat-map-backed map fields.
- `hpp_proto::pmr_stable_traits`: PMR-backed containers with flat-map-backed map fields.
- `hpp_proto::non_owning_traits`: lightweight views (`std::string_view`, `hpp_proto::equality_comparable_span`).
- `hpp_proto::keep_unknown_fields<BaseTraits>`: decorator that records unknown fields for the chosen base traits.

> __Notes__
>
> - Map fields in `non_owning_traits` are represented as sequences of key/value pairs and are not deduplicated. When duplicate keys exist, treat the final entry as authoritative.
> - Keep lifetime semantics aligned. Do not alias `repeated_t`/`map_t` to trivially destructible views (like `std::span`) while `string_t`/`bytes_t` remain owning types (`std::string`); otherwise nested values may leak resources because their destructors never run.

The compiler generates several header files for each .proto file, transforming the filename and extension as follows:

- The  `.proto` extension is replaced with  `.msg.hpp`, `.pb.hpp`, `.glz.hpp` and `.desc.hpp` for different header file types.
- The proto path (specified with --proto_path= or -I flags) is replaced with the output path (specified with the --hpp_out flag).

Example CMake configuration:

```cmake
add_library(non_owning_unittest_proto3_proto_lib INTERFACE)
protobuf_generate_hpp(
    TARGET non_owning_unittest_proto3_proto_lib
    IMPORT_DIRS ${CMAKE_CURRENT_SOURCE_DIR}
    PROTOC_OUT_DIR ${CMAKE_CURRENT_BINARY_DIR}
    PROTOS ${CMAKE_CURRENT_SOURCE_DIR}/google/protobuf/unittest_proto3.proto
    PLUGIN_OPTIONS namespace_prefix=non_owning,directory_prefix=non_owning)
```

### Compiler Invocation from command line

You can invoke the hpp-proto plugin from the command line with the following command:

```
protoc --hpp_out=<output_dir> [--hpp_opt=<plugin_option>] [--proto_path=<dir>] <protobuf_files...>
```

## Packages

If a .proto file contains a package declaration, the entire contents are placed in a corresponding C++ namespace. For example:

```
package foo.bar;
```

All declarations in the file will reside in the `foo::bar` namespace.

If you need to use both `hpp-proto` and the official Google Protobuf library in the same program, you can use the namespace_prefix option to customize the top-level namespace in the generated files. For example:

```
protoc --proto_path=src --hpp_out build/gen  --hpp_opt=namespace_prefix=baz src/foo.proto
```

This command will place all declarations in the `baz::foo::bar` namespace.

## Selecting traits per scope

Message templates default to `hpp_proto::default_traits`. Switch to another configuration by instantiating the template explicitly:

```cpp
using Owning = tutorial::Person<>;
using View = tutorial::Person<hpp_proto::non_owning_traits>;
```

## Messages

All generated messages are templates parameterized on `Traits`, because each struct embeds the trait-governed `unknown_fields_` member. The only exception is `google::protobuf::Empty`, which intentionally omits unknown-field storage and therefore stays as a plain struct.

```
message Foo {
  int32  f1 = 1;
  string f2 = 2;
  bytes  f3 = 3;
}
```

Generates:

```cpp
template <typename Traits = ::hpp_proto::default_traits>
struct Foo {
  using hpp_proto_traits_type = Traits;
  std::int32_t f1 = {};
  typename Traits::string_t f2;
  typename Traits::bytes_t f3;

  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const Foo &) const = default;
};

using FooOwning = Foo<>;
using FooView = Foo<hpp_proto::non_owning_traits>;
using FooPmr = Foo<my_pmr_traits>;
```

Nested message and enum definitions follow the same template/enum rules but are emitted into an underscore-suffixed namespace that mirrors their enclosing scope. For example:

```
message Outer {
  message Inner {
    string payload = 1;
  }
  enum Kind {
    KIND_UNKNOWN = 0;
    KIND_OK = 1;
  }
  Inner inner = 1;
  Kind kind = 2;
}
```

Generates:

```cpp

namespace Outer_ {
template <typename Traits = ::hpp_proto::default_traits>
struct Inner {
  using hpp_proto_traits_type = Traits;
  typename Traits::string_t payload;
  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const Inner &) const = default;
};

enum Kind {
  KIND_UNKNOWN = 0,
  KIND_OK = 1,
};
} // namespace Outer_

template <typename Traits = ::hpp_proto::default_traits>
struct Outer {
  using hpp_proto_traits_type = Traits;
  using Inner = ::Outer_::Inner<Traits>;
  using Kind = ::Outer_::Kind;

  std::optional<Inner> inner;
  Kind kind = Kind::KIND_UNKNOWN;
  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const Outer &) const = default;
};
```

Notice how the top-level `Outer` template aliases the nested types via `using Inner = ::Outer_::Inner<Traits>;` and `using Kind = ::Outer_::Kind;`. This pattern keeps nested names unique (the actual implementations live in the underscore-suffixed `Outer_` namespace) without relying on anonymous namespaces while preserving the original Proto scoping semantics.

All generated support code (`pb_meta`, `glz::meta`, descriptors) mirrors the same `Traits` parameter.

## Fields

### Implicit Presence Fields (proto3)

```
syntax = "proto3";
message Foo {
  int32  f1 = 1;
  string f2 = 2;
  bytes  f3 = 3;
}
```

Generates:

```cpp
template <typename Traits = ::hpp_proto::default_traits>
struct Foo {
  using hpp_proto_traits_type = Traits;
  std::int32_t f1 = {};
  typename Traits::string_t f2;
  typename Traits::bytes_t f3;

  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const Foo &) const = default;
};
```

Selecting different traits swaps the underlying storage types automatically.

### Explicit Presence Fields (proto2)

```
syntax = "proto2";
message Foo {
  optional int32  f1 = 1;
  optional string f2 = 2;
  optional bytes  f3 = 3;
  optional int64  f4 = 4 [default = 100];
}
```

Generates:

```cpp
template <typename Traits = ::hpp_proto::default_traits>
struct Foo {
  using hpp_proto_traits_type = Traits;
  hpp_proto::optional<std::int32_t> f1;
  hpp_proto::optional<typename Traits::string_t> f2;
  hpp_proto::optional<typename Traits::bytes_t> f3;
  hpp_proto::optional<std::int64_t, 100> f4;

  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const Foo &) const = default;
};
```

`hpp_proto::optional<T, DefaultValue>` is used for explicit presence fields. It is similar to `std::optional<T>`, but with protobuf-specific behavior:

- It stores the protobuf default value and returns that value when the field is not present.
- It is optimized for protobuf field storage.
- `hpp_proto::optional<bool>` is specialized to avoid common `std::optional<bool>` pitfalls.

For `optional<bool>`, implicit `operator bool()` is intentionally removed. This prevents accidental checks like `if (opt_bool)` from being interpreted as a value check when they are actually presence checks. Use:

- `.has_value()` to check presence
- `*opt_bool` or `.value()` to read the boolean value

Compared with `std::optional<T>`:

| Feature | `std::optional<T>` | `hpp_proto::optional<T>` |
| :--- | :--- | :--- |
| Missing value | `nullopt` / exception on value access | protobuf default value |
| `if (opt)` for `bool` | allowed (checks presence) | disabled |
| Protobuf default support | no | yes (`optional<T, Default>`) |

### Optional Embedded Message Fields (proto2 and proto3)

For a nested message `Bar`:

```
optional Bar foo = 1;  // proto2 syntax
Bar foo = 1;           // proto3 syntax
```

the generated member is:

```cpp
std::optional<Bar<Traits>> foo;
```

When a message references itself (directly or transitively), the generator switches to the trait-provided recursive holder:

```cpp
Traits::template optional_indirect_t<MyMessage<Traits>> child;
```

`optional_indirect_t` defaults to `hpp_proto::optional_indirect` in owning mode and `hpp_proto::optional_indirect_view` for non-owning traits. This pattern appears in generated code such as `TestRecursiveMessage` from `google/protobuf/unittest.proto`.

### Repeated Fields

Repeated fields use the trait-defined storage:

```cpp
Traits::template repeated_t<std::int32_t> numbers;
Traits::template repeated_t<typename Traits::string_t> names;
```

The default trait maps to `std::vector<T>`, while `non_owning_traits` exposes `hpp_proto::equality_comparable_span<const T>`.

### Oneof fields

For oneof fields:

```protobuf
message TestOneof {
  oneof foo {
    int32 foo_int = 1;
    string foo_string = 2;
    NestedMessage foo_message = 3;
  }
  message NestedMessage {
    double required_double = 1;
  }
}
```

The compiler maps the oneof field to `std::variant`, with the first alternative being `std::monostate`:

```cpp
namespace TestOneof_ {
template <typename Traits = ::hpp_proto::default_traits>
struct NestedMessage {
  double required_double = {};

  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const NestedMessage &) const = default;
};
}

template <typename Traits = ::hpp_proto::default_traits>
struct TestOneof {
  using hpp_proto_traits_type = Traits;
  using NestedMessage = TestOneof_::NestedMessage<Traits>;

  enum class foo_oneof_case : int {
    foo_int = 1,
    foo_string = 2,
    foo_message = 3
  };

  std::variant<std::monostate, std::int32_t, typename Traits::string_t, NestedMessage> foo;

  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const TestOneof &) const = default;
};
```

### Map fields

For `map` fields:

```proto
import "hpp_proto/hpp_options.proto";

message TestMap {
  map<int32, int32> map1 = 1;
  map<string, int32> map2 = 2 [(hpp.proto.hpp_field_opts).string_keyed_map = 'std::unordered_map'];
  map<int32, int32> map3 = 3 [(hpp.proto.hpp_field_opts).numeric_keyed_map = 'std::map'];;
}
```

Map fields become trait-backed containers:

```cpp
template <typename Traits = ::hpp_proto::default_traits>
struct TestMap {
  using hpp_proto_traits_type = Traits;
  Traits::template map_t<std::int32_t, std::int32_t> map1;
  Traits::template map_t<typename Traits::string_t, std::int32_t> map2;
  Traits::template map_t<std::int32_t, std::int32_t> map3;

  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const TestMap &) const = default;
};
```

`default_traits` maps map fields to `flat_map` for integral keys and `std::unordered_map` for string keys. `stable_traits` and `pmr_stable_traits` always use `flat_map`. `non_owning_traits` exposes `hpp_proto::equality_comparable_span<const std::pair<Key, Value>>`. For `non_owning_traits`, key deduplication is the caller's responsibility; when duplicates appear during parsing, only the final entry should be treated as valid.

### Any Type

For google.protobuf.Any fields:

```protobuf
message TestAny {
  google.protobuf.Any any_value = 2;
}
```

The compiler generates a templated struct referencing the matching traits-aware `google::protobuf::Any`:

```cpp
template <typename Traits = ::hpp_proto::default_traits>
struct TestAny {
  using hpp_proto_traits_type = Traits;
  std::int32_t int32_value = {};
  std::optional<google::protobuf::Any<Traits>> any_value;
  Traits::template repeated_t<google::protobuf::Any<Traits>> repeated_any_value;
  typename Traits::string_t text;

  [[no_unique_address]] hpp_proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator==(const TestAny &) const = default;
};
```

`hpp_proto::pack_any` and `hpp_proto::unpack_any` automatically track the selected trait.

<details open><summary> Owning Traits (`hpp_proto::default_traits`)</summary>
<p>

```cpp
using TestAny = protobuf_unittest::TestAny<>;

TestAny message;
google::protobuf::FieldMask<> fm;
fm.paths = {"/usr/share", "/usr/local/share"};
assert(hpp_proto::pack_any(message.any_value.emplace(), fm).ok());

std::vector<char> buf;
assert(hpp_proto::write_binpb(message, buf).ok());

TestAny round_trip;
assert(hpp_proto::read_binpb(round_trip, buf).ok());
google::protobuf::FieldMask<> fm2;
assert(hpp_proto::unpack_any(round_trip.any_value.value(), fm2).ok());
```

Regardless of return type (`std::expected` or status), `read_binpb`/`read_json` do not catch any exceptions thrown by standard containers. If allocation failures are possible on your target platform, catch `std::bad_alloc` explicitly.

</p>
</details>
<details open><summary> View Traits (`hpp_proto::non_owning_traits`)</summary>
<p>

```cpp
using namespace std::string_view_literals;
using TestAnyView = protobuf_unittest::TestAny<hpp_proto::non_owning_traits>;

std::pmr::monotonic_buffer_resource pool;
auto ctx = hpp_proto::alloc_from{pool};

TestAnyView message;
std::array<std::string_view, 2> paths{"/usr/share"sv, "/usr/local/share"sv};
google::protobuf::FieldMask<hpp_proto::non_owning_traits> fm;
fm.paths = paths;
assert(hpp_proto::pack_any(message.any_value.emplace(), fm, ctx).ok());

std::vector<char> buf;
assert(hpp_proto::write_binpb(message, buf).ok());

TestAnyView round_trip;
assert(hpp_proto::read_binpb(round_trip, buf, ctx).ok());
google::protobuf::FieldMask<hpp_proto::non_owning_traits> fm2;
assert(hpp_proto::unpack_any(round_trip.any_value.value(), fm2, ctx).ok());
```

</p>
</details>
