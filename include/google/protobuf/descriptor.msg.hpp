// clang-format off
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// generation command line:
//    protoc --plugin=protoc-gen-hpp=/path/to/protoc-gen-hpp
//           --hpp_out proto2_explicit_presence=.google.protobuf.FieldDescriptorProto.oneof_index,proto2_explicit_presence=.google.protobuf.FieldOptions.packed:${out_dir}
//           google/protobuf/descriptor.proto

#pragma once

#include <hpp_proto/field_types.hpp>
// @@protoc_insertion_point(includes)


namespace google::protobuf {
//NOLINTBEGIN(performance-enum-size)

enum class Edition {
  EDITION_UNKNOWN = 0,
  EDITION_LEGACY = 900,
  EDITION_PROTO2 = 998,
  EDITION_PROTO3 = 999,
  EDITION_2023 = 1000,
  EDITION_2024 = 1001,
  EDITION_1_TEST_ONLY = 1,
  EDITION_2_TEST_ONLY = 2,
  EDITION_99997_TEST_ONLY = 99997,
  EDITION_99998_TEST_ONLY = 99998,
  EDITION_99999_TEST_ONLY = 99999,
  EDITION_MAX = 2147483647 
};

constexpr bool is_valid(Edition value){
  int v = static_cast<int>(value);
  constexpr std::array<int, 12> valid_values{0,1,2,900,998,999,1000,1001,99997,99998,99999,2147483647};
  return std::ranges::any_of(valid_values, [v](int u){ return u==v; });
}

enum class SymbolVisibility {
  VISIBILITY_UNSET = 0,
  VISIBILITY_LOCAL = 1,
  VISIBILITY_EXPORT = 2 
};

constexpr bool is_valid(SymbolVisibility value){
  int v = static_cast<int>(value);
  return v >= 0 && v <= 2;
}

namespace UninterpretedOption__ {
  template <typename Traits = ::hpp::proto::default_traits>
  struct NamePart {
    using hpp_proto_traits_type = Traits;
    typename Traits::string_t name_part;
    bool is_extension = {};

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const NamePart&) const = default;
  };

} //namespace UninterpretedOption__

template <typename Traits = ::hpp::proto::default_traits>
struct UninterpretedOption {
  using hpp_proto_traits_type = Traits;
  using NamePart = UninterpretedOption__::NamePart<Traits>;

  typename Traits::template vector_t<NamePart> name;
  typename Traits::string_t identifier_value;
  std::uint64_t positive_int_value = {};
  std::int64_t negative_int_value = {};
  double double_value = {};
  typename Traits::bytes_t string_value;
  typename Traits::string_t aggregate_value;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const UninterpretedOption&) const = default;
};

namespace FeatureSet__ {
  enum class FieldPresence {
    FIELD_PRESENCE_UNKNOWN = 0,
    EXPLICIT = 1,
    IMPLICIT = 2,
    LEGACY_REQUIRED = 3 
  };

  constexpr bool is_valid(FieldPresence value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 3;
  }

  enum class EnumType {
    ENUM_TYPE_UNKNOWN = 0,
    OPEN = 1,
    CLOSED = 2 
  };

  constexpr bool is_valid(EnumType value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  enum class RepeatedFieldEncoding {
    REPEATED_FIELD_ENCODING_UNKNOWN = 0,
    PACKED = 1,
    EXPANDED = 2 
  };

  constexpr bool is_valid(RepeatedFieldEncoding value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  enum class Utf8Validation {
    UTF8_VALIDATION_UNKNOWN = 0,
    VERIFY = 2,
    NONE = 3 
  };

  constexpr bool is_valid(Utf8Validation value){
    int v = static_cast<int>(value);
    constexpr std::array<int, 3> valid_values{0,2,3};
    return std::ranges::any_of(valid_values, [v](int u){ return u==v; });
  }

  enum class MessageEncoding {
    MESSAGE_ENCODING_UNKNOWN = 0,
    LENGTH_PREFIXED = 1,
    DELIMITED = 2 
  };

  constexpr bool is_valid(MessageEncoding value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  enum class JsonFormat {
    JSON_FORMAT_UNKNOWN = 0,
    ALLOW = 1,
    LEGACY_BEST_EFFORT = 2 
  };

  constexpr bool is_valid(JsonFormat value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  enum class EnforceNamingStyle {
    ENFORCE_NAMING_STYLE_UNKNOWN = 0,
    STYLE2024 = 1,
    STYLE_LEGACY = 2 
  };

  constexpr bool is_valid(EnforceNamingStyle value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  namespace VisibilityFeature__ {
    enum class DefaultSymbolVisibility {
      DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0,
      EXPORT_ALL = 1,
      EXPORT_TOP_LEVEL = 2,
      LOCAL_ALL = 3,
      STRICT = 4 
    };

    constexpr bool is_valid(DefaultSymbolVisibility value){
      int v = static_cast<int>(value);
      return v >= 0 && v <= 4;
    }

  } //namespace VisibilityFeature__

  template <typename Traits = ::hpp::proto::default_traits>
  struct VisibilityFeature {
    using hpp_proto_traits_type = Traits;
    using DefaultSymbolVisibility = google::protobuf::FeatureSet__::VisibilityFeature__::DefaultSymbolVisibility;

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const VisibilityFeature&) const = default;
  };

} //namespace FeatureSet__

template <typename Traits = ::hpp::proto::default_traits>
struct FeatureSet {
  using hpp_proto_traits_type = Traits;
  using FieldPresence = google::protobuf::FeatureSet__::FieldPresence;
  using EnumType = google::protobuf::FeatureSet__::EnumType;
  using RepeatedFieldEncoding = google::protobuf::FeatureSet__::RepeatedFieldEncoding;
  using Utf8Validation = google::protobuf::FeatureSet__::Utf8Validation;
  using MessageEncoding = google::protobuf::FeatureSet__::MessageEncoding;
  using JsonFormat = google::protobuf::FeatureSet__::JsonFormat;
  using EnforceNamingStyle = google::protobuf::FeatureSet__::EnforceNamingStyle;
  using VisibilityFeature = FeatureSet__::VisibilityFeature<Traits>;

  FieldPresence field_presence = FieldPresence::FIELD_PRESENCE_UNKNOWN;
  EnumType enum_type = EnumType::ENUM_TYPE_UNKNOWN;
  RepeatedFieldEncoding repeated_field_encoding = RepeatedFieldEncoding::REPEATED_FIELD_ENCODING_UNKNOWN;
  Utf8Validation utf8_validation = Utf8Validation::UTF8_VALIDATION_UNKNOWN;
  MessageEncoding message_encoding = MessageEncoding::MESSAGE_ENCODING_UNKNOWN;
  JsonFormat json_format = JsonFormat::JSON_FORMAT_UNKNOWN;
  EnforceNamingStyle enforce_naming_style = EnforceNamingStyle::ENFORCE_NAMING_STYLE_UNKNOWN;
  VisibilityFeature::DefaultSymbolVisibility default_symbol_visibility = VisibilityFeature::DefaultSymbolVisibility::DEFAULT_SYMBOL_VISIBILITY_UNKNOWN;

  struct extension_t {
    using pb_extension = FeatureSet;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const FeatureSet&) const = default;
};

namespace SourceCodeInfo__ {
  template <typename Traits = ::hpp::proto::default_traits>
  struct Location {
    using hpp_proto_traits_type = Traits;
    typename Traits::template vector_t<std::int32_t> path;
    typename Traits::template vector_t<std::int32_t> span;
    typename Traits::string_t leading_comments;
    typename Traits::string_t trailing_comments;
    typename Traits::template vector_t<typename Traits::string_t> leading_detached_comments;

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const Location&) const = default;
  };

} //namespace SourceCodeInfo__

template <typename Traits = ::hpp::proto::default_traits>
struct SourceCodeInfo {
  using hpp_proto_traits_type = Traits;
  using Location = SourceCodeInfo__::Location<Traits>;

  typename Traits::template vector_t<Location> location;

  struct extension_t {
    using pb_extension = SourceCodeInfo;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const SourceCodeInfo&) const = default;
};

namespace GeneratedCodeInfo__ {
  namespace Annotation__ {
    enum class Semantic {
      NONE = 0,
      SET = 1,
      ALIAS = 2 
    };

    constexpr bool is_valid(Semantic value){
      int v = static_cast<int>(value);
      return v >= 0 && v <= 2;
    }

  } //namespace Annotation__

  template <typename Traits = ::hpp::proto::default_traits>
  struct Annotation {
    using hpp_proto_traits_type = Traits;
    using Semantic = google::protobuf::GeneratedCodeInfo__::Annotation__::Semantic;
    typename Traits::template vector_t<std::int32_t> path;
    typename Traits::string_t source_file;
    std::int32_t begin = {};
    std::int32_t end = {};
    Semantic semantic = Semantic::NONE;

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const Annotation&) const = default;
  };

} //namespace GeneratedCodeInfo__

template <typename Traits = ::hpp::proto::default_traits>
struct GeneratedCodeInfo {
  using hpp_proto_traits_type = Traits;
  using Annotation = GeneratedCodeInfo__::Annotation<Traits>;

  typename Traits::template vector_t<Annotation> annotation;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const GeneratedCodeInfo&) const = default;
};

namespace FeatureSetDefaults__ {
  template <typename Traits = ::hpp::proto::default_traits>
  struct FeatureSetEditionDefault {
    using hpp_proto_traits_type = Traits;
    google::protobuf::Edition edition = google::protobuf::Edition::EDITION_UNKNOWN;
    std::optional<google::protobuf::FeatureSet<Traits>> overridable_features;
    std::optional<google::protobuf::FeatureSet<Traits>> fixed_features;

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const FeatureSetEditionDefault&) const = default;
  };

} //namespace FeatureSetDefaults__

template <typename Traits = ::hpp::proto::default_traits>
struct FeatureSetDefaults {
  using hpp_proto_traits_type = Traits;
  using FeatureSetEditionDefault = FeatureSetDefaults__::FeatureSetEditionDefault<Traits>;

  typename Traits::template vector_t<FeatureSetEditionDefault> defaults;
  google::protobuf::Edition minimum_edition = google::protobuf::Edition::EDITION_UNKNOWN;
  google::protobuf::Edition maximum_edition = google::protobuf::Edition::EDITION_UNKNOWN;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const FeatureSetDefaults&) const = default;
};

namespace MethodOptions__ {
  enum class IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0,
    NO_SIDE_EFFECTS = 1,
    IDEMPOTENT = 2 
  };

  constexpr bool is_valid(IdempotencyLevel value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

} //namespace MethodOptions__

template <typename Traits = ::hpp::proto::default_traits>
struct MethodOptions {
  using hpp_proto_traits_type = Traits;
  using IdempotencyLevel = google::protobuf::MethodOptions__::IdempotencyLevel;
  bool deprecated = false;
  IdempotencyLevel idempotency_level = IdempotencyLevel::IDEMPOTENCY_UNKNOWN;
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = MethodOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const MethodOptions&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct ServiceOptions {
  using hpp_proto_traits_type = Traits;
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  bool deprecated = false;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = ServiceOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const ServiceOptions&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct EnumOptions {
  using hpp_proto_traits_type = Traits;
  bool allow_alias = {};
  bool deprecated = false;
  bool deprecated_legacy_json_field_conflicts = {};
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = EnumOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const EnumOptions&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct OneofOptions {
  using hpp_proto_traits_type = Traits;
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = OneofOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const OneofOptions&) const = default;
};

namespace FieldOptions__ {
  enum class CType {
    STRING = 0,
    CORD = 1,
    STRING_PIECE = 2 
  };

  constexpr bool is_valid(CType value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  enum class JSType {
    JS_NORMAL = 0,
    JS_STRING = 1,
    JS_NUMBER = 2 
  };

  constexpr bool is_valid(JSType value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  enum class OptionRetention {
    RETENTION_UNKNOWN = 0,
    RETENTION_RUNTIME = 1,
    RETENTION_SOURCE = 2 
  };

  constexpr bool is_valid(OptionRetention value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  enum class OptionTargetType {
    TARGET_TYPE_UNKNOWN = 0,
    TARGET_TYPE_FILE = 1,
    TARGET_TYPE_EXTENSION_RANGE = 2,
    TARGET_TYPE_MESSAGE = 3,
    TARGET_TYPE_FIELD = 4,
    TARGET_TYPE_ONEOF = 5,
    TARGET_TYPE_ENUM = 6,
    TARGET_TYPE_ENUM_ENTRY = 7,
    TARGET_TYPE_SERVICE = 8,
    TARGET_TYPE_METHOD = 9 
  };

  constexpr bool is_valid(OptionTargetType value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 9;
  }

  template <typename Traits = ::hpp::proto::default_traits>
  struct EditionDefault {
    using hpp_proto_traits_type = Traits;
    google::protobuf::Edition edition = google::protobuf::Edition::EDITION_UNKNOWN;
    typename Traits::string_t value;

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const EditionDefault&) const = default;
  };

  template <typename Traits = ::hpp::proto::default_traits>
  struct FeatureSupport {
    using hpp_proto_traits_type = Traits;
    google::protobuf::Edition edition_introduced = google::protobuf::Edition::EDITION_UNKNOWN;
    google::protobuf::Edition edition_deprecated = google::protobuf::Edition::EDITION_UNKNOWN;
    typename Traits::string_t deprecation_warning;
    google::protobuf::Edition edition_removed = google::protobuf::Edition::EDITION_UNKNOWN;

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const FeatureSupport&) const = default;
  };

} //namespace FieldOptions__

template <typename Traits = ::hpp::proto::default_traits>
struct FieldOptions {
  using hpp_proto_traits_type = Traits;
  using CType = google::protobuf::FieldOptions__::CType;
  using JSType = google::protobuf::FieldOptions__::JSType;
  using OptionRetention = google::protobuf::FieldOptions__::OptionRetention;
  using OptionTargetType = google::protobuf::FieldOptions__::OptionTargetType;
  using EditionDefault = FieldOptions__::EditionDefault<Traits>;

  using FeatureSupport = FieldOptions__::FeatureSupport<Traits>;

  CType ctype = CType::STRING;
  hpp::proto::optional<bool> packed;
  JSType jstype = JSType::JS_NORMAL;
  bool lazy = false;
  bool unverified_lazy = false;
  bool deprecated = false;
  bool weak = false;
  bool debug_redact = false;
  OptionRetention retention = OptionRetention::RETENTION_UNKNOWN;
  typename Traits::template vector_t<OptionTargetType> targets;
  typename Traits::template vector_t<EditionDefault> edition_defaults;
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  std::optional<FeatureSupport> feature_support;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = FieldOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const FieldOptions&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct MessageOptions {
  using hpp_proto_traits_type = Traits;
  bool message_set_wire_format = false;
  bool no_standard_descriptor_accessor = false;
  bool deprecated = false;
  bool map_entry = {};
  bool deprecated_legacy_json_field_conflicts = {};
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = MessageOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const MessageOptions&) const = default;
};

namespace FileOptions__ {
  enum class OptimizeMode {
    SPEED = 1,
    CODE_SIZE = 2,
    LITE_RUNTIME = 3 
  };

  constexpr bool is_valid(OptimizeMode value){
    int v = static_cast<int>(value);
    return v >= 1 && v <= 3;
  }

} //namespace FileOptions__

template <typename Traits = ::hpp::proto::default_traits>
struct FileOptions {
  using hpp_proto_traits_type = Traits;
  using OptimizeMode = google::protobuf::FileOptions__::OptimizeMode;
  typename Traits::string_t java_package;
  typename Traits::string_t java_outer_classname;
  bool java_multiple_files = false;
  bool java_generate_equals_and_hash = {};
  bool java_string_check_utf8 = false;
  OptimizeMode optimize_for = OptimizeMode::SPEED;
  typename Traits::string_t go_package;
  bool cc_generic_services = false;
  bool java_generic_services = false;
  bool py_generic_services = false;
  bool deprecated = false;
  bool cc_enable_arenas = true;
  typename Traits::string_t objc_class_prefix;
  typename Traits::string_t csharp_namespace;
  typename Traits::string_t swift_prefix;
  typename Traits::string_t php_class_prefix;
  typename Traits::string_t php_namespace;
  typename Traits::string_t php_metadata_namespace;
  typename Traits::string_t ruby_package;
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = FileOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const FileOptions&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct MethodDescriptorProto {
  using hpp_proto_traits_type = Traits;
  typename Traits::string_t name;
  typename Traits::string_t input_type;
  typename Traits::string_t output_type;
  std::optional<google::protobuf::MethodOptions<Traits>> options;
  bool client_streaming = false;
  bool server_streaming = false;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const MethodDescriptorProto&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct ServiceDescriptorProto {
  using hpp_proto_traits_type = Traits;
  typename Traits::string_t name;
  typename Traits::template vector_t<google::protobuf::MethodDescriptorProto<Traits>> method;
  std::optional<google::protobuf::ServiceOptions<Traits>> options;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const ServiceDescriptorProto&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct OneofDescriptorProto {
  using hpp_proto_traits_type = Traits;
  typename Traits::string_t name;
  std::optional<google::protobuf::OneofOptions<Traits>> options;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const OneofDescriptorProto&) const = default;
};

namespace FieldDescriptorProto__ {
  enum class Type {
    TYPE_DOUBLE = 1,
    TYPE_FLOAT = 2,
    TYPE_INT64 = 3,
    TYPE_UINT64 = 4,
    TYPE_INT32 = 5,
    TYPE_FIXED64 = 6,
    TYPE_FIXED32 = 7,
    TYPE_BOOL = 8,
    TYPE_STRING = 9,
    TYPE_GROUP = 10,
    TYPE_MESSAGE = 11,
    TYPE_BYTES = 12,
    TYPE_UINT32 = 13,
    TYPE_ENUM = 14,
    TYPE_SFIXED32 = 15,
    TYPE_SFIXED64 = 16,
    TYPE_SINT32 = 17,
    TYPE_SINT64 = 18 
  };

  constexpr bool is_valid(Type value){
    int v = static_cast<int>(value);
    return v >= 1 && v <= 18;
  }

  enum class Label {
    LABEL_OPTIONAL = 1,
    LABEL_REPEATED = 3,
    LABEL_REQUIRED = 2 
  };

  constexpr bool is_valid(Label value){
    int v = static_cast<int>(value);
    return v >= 1 && v <= 3;
  }

} //namespace FieldDescriptorProto__

template <typename Traits = ::hpp::proto::default_traits>
struct FieldDescriptorProto {
  using hpp_proto_traits_type = Traits;
  using Type = google::protobuf::FieldDescriptorProto__::Type;
  using Label = google::protobuf::FieldDescriptorProto__::Label;
  typename Traits::string_t name;
  std::int32_t number = {};
  Label label = Label::LABEL_OPTIONAL;
  Type type = Type::TYPE_DOUBLE;
  typename Traits::string_t type_name;
  typename Traits::string_t extendee;
  typename Traits::string_t default_value;
  hpp::proto::optional<std::int32_t> oneof_index;
  typename Traits::string_t json_name;
  std::optional<google::protobuf::FieldOptions<Traits>> options;
  bool proto3_optional = {};

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const FieldDescriptorProto&) const = default;
};

namespace ExtensionRangeOptions__ {
  enum class VerificationState {
    DECLARATION = 0,
    UNVERIFIED = 1 
  };

  constexpr bool is_valid(VerificationState value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 1;
  }

  template <typename Traits = ::hpp::proto::default_traits>
  struct Declaration {
    using hpp_proto_traits_type = Traits;
    std::int32_t number = {};
    typename Traits::string_t full_name;
    typename Traits::string_t type;
    bool reserved = {};
    bool repeated = {};

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const Declaration&) const = default;
  };

} //namespace ExtensionRangeOptions__

template <typename Traits = ::hpp::proto::default_traits>
struct ExtensionRangeOptions {
  using hpp_proto_traits_type = Traits;
  using VerificationState = google::protobuf::ExtensionRangeOptions__::VerificationState;
  using Declaration = ExtensionRangeOptions__::Declaration<Traits>;

  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;
  typename Traits::template vector_t<Declaration> declaration;
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  VerificationState verification = VerificationState::UNVERIFIED;

  struct extension_t {
    using pb_extension = ExtensionRangeOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const ExtensionRangeOptions&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct EnumValueOptions {
  using hpp_proto_traits_type = Traits;
  bool deprecated = false;
  std::optional<google::protobuf::FeatureSet<Traits>> features;
  bool debug_redact = false;
  std::optional<google::protobuf::FieldOptions__::FeatureSupport<Traits>> feature_support;
  typename Traits::template vector_t<google::protobuf::UninterpretedOption<Traits>> uninterpreted_option;

  struct extension_t {
    using pb_extension = EnumValueOptions;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const EnumValueOptions&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct EnumValueDescriptorProto {
  using hpp_proto_traits_type = Traits;
  typename Traits::string_t name;
  std::int32_t number = {};
  std::optional<google::protobuf::EnumValueOptions<Traits>> options;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const EnumValueDescriptorProto&) const = default;
};

namespace EnumDescriptorProto__ {
  template <typename Traits = ::hpp::proto::default_traits>
  struct EnumReservedRange {
    using hpp_proto_traits_type = Traits;
    std::int32_t start = {};
    std::int32_t end = {};

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const EnumReservedRange&) const = default;
  };

} //namespace EnumDescriptorProto__

template <typename Traits = ::hpp::proto::default_traits>
struct EnumDescriptorProto {
  using hpp_proto_traits_type = Traits;
  using EnumReservedRange = EnumDescriptorProto__::EnumReservedRange<Traits>;

  typename Traits::string_t name;
  typename Traits::template vector_t<google::protobuf::EnumValueDescriptorProto<Traits>> value;
  std::optional<google::protobuf::EnumOptions<Traits>> options;
  typename Traits::template vector_t<EnumReservedRange> reserved_range;
  typename Traits::template vector_t<typename Traits::string_t> reserved_name;
  google::protobuf::SymbolVisibility visibility = google::protobuf::SymbolVisibility::VISIBILITY_UNSET;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const EnumDescriptorProto&) const = default;
};

namespace DescriptorProto__ {
  template <typename Traits = ::hpp::proto::default_traits>
  struct ExtensionRange {
    using hpp_proto_traits_type = Traits;
    std::int32_t start = {};
    std::int32_t end = {};
    std::optional<google::protobuf::ExtensionRangeOptions<Traits>> options;

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const ExtensionRange&) const = default;
  };

  template <typename Traits = ::hpp::proto::default_traits>
  struct ReservedRange {
    using hpp_proto_traits_type = Traits;
    std::int32_t start = {};
    std::int32_t end = {};

    [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
    bool operator == (const ReservedRange&) const = default;
  };

} //namespace DescriptorProto__

template <typename Traits = ::hpp::proto::default_traits>
struct DescriptorProto {
  using hpp_proto_traits_type = Traits;
  using ExtensionRange = DescriptorProto__::ExtensionRange<Traits>;

  using ReservedRange = DescriptorProto__::ReservedRange<Traits>;

  typename Traits::string_t name;
  typename Traits::template vector_t<google::protobuf::FieldDescriptorProto<Traits>> field;
  typename Traits::template vector_t<google::protobuf::FieldDescriptorProto<Traits>> extension;
  typename Traits::template vector_t<DescriptorProto> nested_type;
  typename Traits::template vector_t<google::protobuf::EnumDescriptorProto<Traits>> enum_type;
  typename Traits::template vector_t<ExtensionRange> extension_range;
  typename Traits::template vector_t<google::protobuf::OneofDescriptorProto<Traits>> oneof_decl;
  std::optional<google::protobuf::MessageOptions<Traits>> options;
  typename Traits::template vector_t<ReservedRange> reserved_range;
  typename Traits::template vector_t<typename Traits::string_t> reserved_name;
  google::protobuf::SymbolVisibility visibility = google::protobuf::SymbolVisibility::VISIBILITY_UNSET;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const DescriptorProto&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct FileDescriptorProto {
  using hpp_proto_traits_type = Traits;
  typename Traits::string_t name;
  typename Traits::string_t package;
  typename Traits::template vector_t<typename Traits::string_t> dependency;
  typename Traits::template vector_t<std::int32_t> public_dependency;
  typename Traits::template vector_t<std::int32_t> weak_dependency;
  typename Traits::template vector_t<typename Traits::string_t> option_dependency;
  typename Traits::template vector_t<google::protobuf::DescriptorProto<Traits>> message_type;
  typename Traits::template vector_t<google::protobuf::EnumDescriptorProto<Traits>> enum_type;
  typename Traits::template vector_t<google::protobuf::ServiceDescriptorProto<Traits>> service;
  typename Traits::template vector_t<google::protobuf::FieldDescriptorProto<Traits>> extension;
  std::optional<google::protobuf::FileOptions<Traits>> options;
  std::optional<google::protobuf::SourceCodeInfo<Traits>> source_code_info;
  typename Traits::string_t syntax;
  google::protobuf::Edition edition = google::protobuf::Edition::EDITION_UNKNOWN;

  [[no_unique_address]] Traits::unknown_fields_t unknown_fields_;
  bool operator == (const FileDescriptorProto&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct FileDescriptorSet {
  using hpp_proto_traits_type = Traits;
  typename Traits::template vector_t<google::protobuf::FileDescriptorProto<Traits>> file;

  struct extension_t {
    using pb_extension = FileDescriptorSet;
    Traits::template map_t<uint32_t, typename Traits::bytes_t> fields;
    bool operator==(const extension_t &other) const = default;
  } extensions;

  [[nodiscard]] hpp::proto::status get_extension(auto &ext, hpp::proto::concepts::is_option_type auto && ...option) const {
    return ext.get_from(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] auto set_extension(const auto &ext,
                                   hpp::proto::concepts::is_option_type auto &&...option) {
    return ext.set_to(*this, std::forward<decltype(option)>(option)...);
  }
  [[nodiscard]] bool has_extension(const auto &ext) const {
    return ext.in(*this);
  }

  bool operator == (const FileDescriptorSet&) const = default;
};

template <typename Traits>
constexpr auto message_type_url(const UninterpretedOption__::NamePart<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.UninterpretedOption.NamePart">{}; }
template <typename Traits>
constexpr auto message_type_url(const UninterpretedOption<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.UninterpretedOption">{}; }
template <typename Traits>
constexpr auto message_type_url(const FeatureSet__::VisibilityFeature<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FeatureSet.VisibilityFeature">{}; }
template <typename Traits>
constexpr auto message_type_url(const FeatureSet<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FeatureSet">{}; }
template <typename Traits>
constexpr auto message_type_url(const SourceCodeInfo__::Location<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.SourceCodeInfo.Location">{}; }
template <typename Traits>
constexpr auto message_type_url(const SourceCodeInfo<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.SourceCodeInfo">{}; }
template <typename Traits>
constexpr auto message_type_url(const GeneratedCodeInfo__::Annotation<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.GeneratedCodeInfo.Annotation">{}; }
template <typename Traits>
constexpr auto message_type_url(const GeneratedCodeInfo<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.GeneratedCodeInfo">{}; }
template <typename Traits>
constexpr auto message_type_url(const FeatureSetDefaults__::FeatureSetEditionDefault<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault">{}; }
template <typename Traits>
constexpr auto message_type_url(const FeatureSetDefaults<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FeatureSetDefaults">{}; }
template <typename Traits>
constexpr auto message_type_url(const MethodOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.MethodOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const ServiceOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.ServiceOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const EnumOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.EnumOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const OneofOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.OneofOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const FieldOptions__::EditionDefault<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FieldOptions.EditionDefault">{}; }
template <typename Traits>
constexpr auto message_type_url(const FieldOptions__::FeatureSupport<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FieldOptions.FeatureSupport">{}; }
template <typename Traits>
constexpr auto message_type_url(const FieldOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FieldOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const MessageOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.MessageOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const FileOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FileOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const MethodDescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.MethodDescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const ServiceDescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.ServiceDescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const OneofDescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.OneofDescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const FieldDescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FieldDescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const ExtensionRangeOptions__::Declaration<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.ExtensionRangeOptions.Declaration">{}; }
template <typename Traits>
constexpr auto message_type_url(const ExtensionRangeOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.ExtensionRangeOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const EnumValueOptions<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.EnumValueOptions">{}; }
template <typename Traits>
constexpr auto message_type_url(const EnumValueDescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.EnumValueDescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const EnumDescriptorProto__::EnumReservedRange<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.EnumDescriptorProto.EnumReservedRange">{}; }
template <typename Traits>
constexpr auto message_type_url(const EnumDescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.EnumDescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const DescriptorProto__::ExtensionRange<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.DescriptorProto.ExtensionRange">{}; }
template <typename Traits>
constexpr auto message_type_url(const DescriptorProto__::ReservedRange<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.DescriptorProto.ReservedRange">{}; }
template <typename Traits>
constexpr auto message_type_url(const DescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.DescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const FileDescriptorProto<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FileDescriptorProto">{}; }
template <typename Traits>
constexpr auto message_type_url(const FileDescriptorSet<Traits>&) { return hpp::proto::string_literal<"type.googleapis.com/google.protobuf.FileDescriptorSet">{}; }
// NOLINTEND(performance-enum-size)
} // namespace google::protobuf
// clang-format on
