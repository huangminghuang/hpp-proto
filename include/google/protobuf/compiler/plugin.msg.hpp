// clang-format off
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// generation command line:
//    protoc --plugin=protoc-gen-hpp=/path/to/protoc-gen-hpp
//           --hpp_out proto2_explicit_presence=.google.protobuf.FieldDescriptorProto.oneof_index,proto2_explicit_presence=.google.protobuf.FieldOptions.packed:${out_dir}
//           google/protobuf/compiler/plugin.proto

#pragma once

#include <hpp_proto/field_types.hpp>
#include "google/protobuf/descriptor.msg.hpp"
// @@protoc_insertion_point(includes)


namespace google::protobuf::compiler {
//NOLINTBEGIN(performance-enum-size)

template <typename Traits = ::hpp::proto::default_traits>
struct Version {
  using hpp_proto_traits_type = Traits;
  std::int32_t major = {};
  std::int32_t minor = {};
  std::int32_t patch = {};
  typename Traits::string_t suffix;

  [[no_unique_address]] ::hpp::proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator == (const Version&) const = default;
};

namespace CodeGeneratorResponse_ {
  enum class Feature {
    FEATURE_NONE = 0,
    FEATURE_PROTO3_OPTIONAL = 1,
    FEATURE_SUPPORTS_EDITIONS = 2 
  };

  constexpr bool is_valid(Feature value){
    int v = static_cast<int>(value);
    return v >= 0 && v <= 2;
  }

  template <typename Traits = ::hpp::proto::default_traits>
  struct File {
    using hpp_proto_traits_type = Traits;
    typename Traits::string_t name;
    typename Traits::string_t insertion_point;
    typename Traits::string_t content;
    std::optional<google::protobuf::GeneratedCodeInfo<Traits>> generated_code_info;

    [[no_unique_address]] ::hpp::proto::pb_unknown_fields<Traits> unknown_fields_;
    bool operator == (const File&) const = default;
  };

} //namespace CodeGeneratorResponse_

template <typename Traits = ::hpp::proto::default_traits>
struct CodeGeneratorResponse {
  using hpp_proto_traits_type = Traits;
  using Feature = google::protobuf::compiler::CodeGeneratorResponse_::Feature;
  using File = CodeGeneratorResponse_::File<Traits>;

  typename Traits::string_t error;
  std::uint64_t supported_features = {};
  std::int32_t minimum_edition = {};
  std::int32_t maximum_edition = {};
  Traits::template repeated_t<File> file;

  [[no_unique_address]] ::hpp::proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator == (const CodeGeneratorResponse&) const = default;
};

template <typename Traits = ::hpp::proto::default_traits>
struct CodeGeneratorRequest {
  using hpp_proto_traits_type = Traits;
  Traits::template repeated_t<typename Traits::string_t> file_to_generate;
  typename Traits::string_t parameter;
  Traits::template repeated_t<google::protobuf::FileDescriptorProto<Traits>> proto_file;
  Traits::template repeated_t<google::protobuf::FileDescriptorProto<Traits>> source_file_descriptors;
  std::optional<google::protobuf::compiler::Version<Traits>> compiler_version;

  [[no_unique_address]] ::hpp::proto::pb_unknown_fields<Traits> unknown_fields_;
  bool operator == (const CodeGeneratorRequest&) const = default;
};

template <typename Traits>
constexpr auto message_type_url(const Version<Traits>&) { return ::hpp::proto::string_literal<"type.googleapis.com/google.protobuf.compiler.Version">{}; }
template <typename Traits>
constexpr auto message_type_url(const CodeGeneratorResponse_::File<Traits>&) { return ::hpp::proto::string_literal<"type.googleapis.com/google.protobuf.compiler.CodeGeneratorResponse.File">{}; }
template <typename Traits>
constexpr auto message_type_url(const CodeGeneratorResponse<Traits>&) { return ::hpp::proto::string_literal<"type.googleapis.com/google.protobuf.compiler.CodeGeneratorResponse">{}; }
template <typename Traits>
constexpr auto message_type_url(const CodeGeneratorRequest<Traits>&) { return ::hpp::proto::string_literal<"type.googleapis.com/google.protobuf.compiler.CodeGeneratorRequest">{}; }
// NOLINTEND(performance-enum-size)
} // namespace google::protobuf::compiler
// clang-format on
