// clang-format off
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// generation command line:
//    protoc --plugin=protoc-gen-hpp=/path/to/protoc-gen-hpp
//           --hpp_out proto2_explicit_presence=.google.protobuf.FieldDescriptorProto.oneof_index,proto2_explicit_presence=.google.protobuf.FieldOptions.packed:${out_dir}
//           google/protobuf/descriptor.proto

#pragma once

#include <hpp_proto/json.hpp>
#include "google/protobuf/descriptor.msg.hpp"

template <typename Traits>
struct glz::meta<google::protobuf::FileDescriptorSet<Traits>> {
  using T = google::protobuf::FileDescriptorSet<Traits>;
  static constexpr auto value = object(
    "file", ::hpp_proto::as_optional_ref<&T::file>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FileDescriptorSet<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::FileDescriptorProto<Traits>> {
  using T = google::protobuf::FileDescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "package", ::hpp_proto::as_optional_ref<&T::package>,
    "dependency", ::hpp_proto::as_optional_ref<&T::dependency>,
    "publicDependency", ::hpp_proto::as_optional_ref<&T::public_dependency>,
    "weakDependency", ::hpp_proto::as_optional_ref<&T::weak_dependency>,
    "optionDependency", ::hpp_proto::as_optional_ref<&T::option_dependency>,
    "messageType", ::hpp_proto::as_optional_ref<&T::message_type>,
    "enumType", ::hpp_proto::as_optional_ref<&T::enum_type>,
    "service", ::hpp_proto::as_optional_ref<&T::service>,
    "extension", ::hpp_proto::as_optional_ref<&T::extension>,
    "options", &T::options,
    "sourceCodeInfo", &T::source_code_info,
    "syntax", ::hpp_proto::as_optional_ref<&T::syntax>,
    "edition", ::hpp_proto::as_optional_ref<&T::edition, google::protobuf::Edition::EDITION_UNKNOWN>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FileDescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::DescriptorProto<Traits>> {
  using T = google::protobuf::DescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "field", ::hpp_proto::as_optional_ref<&T::field>,
    "extension", ::hpp_proto::as_optional_ref<&T::extension>,
    "nestedType", ::hpp_proto::as_optional_ref<&T::nested_type>,
    "enumType", ::hpp_proto::as_optional_ref<&T::enum_type>,
    "extensionRange", ::hpp_proto::as_optional_ref<&T::extension_range>,
    "oneofDecl", ::hpp_proto::as_optional_ref<&T::oneof_decl>,
    "options", &T::options,
    "reservedRange", ::hpp_proto::as_optional_ref<&T::reserved_range>,
    "reservedName", ::hpp_proto::as_optional_ref<&T::reserved_name>,
    "visibility", ::hpp_proto::as_optional_ref<&T::visibility, google::protobuf::SymbolVisibility::VISIBILITY_UNSET>);
};

template <typename Traits>
struct glz::meta<google::protobuf::DescriptorProto_::ExtensionRange<Traits>> {
  using T = google::protobuf::DescriptorProto_::ExtensionRange<Traits>;
  static constexpr auto value = object(
    "start", ::hpp_proto::as_optional_ref<&T::start>,
    "end", ::hpp_proto::as_optional_ref<&T::end>,
    "options", &T::options);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::DescriptorProto_::ExtensionRange<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::DescriptorProto_::ReservedRange<Traits>> {
  using T = google::protobuf::DescriptorProto_::ReservedRange<Traits>;
  static constexpr auto value = object(
    "start", ::hpp_proto::as_optional_ref<&T::start>,
    "end", ::hpp_proto::as_optional_ref<&T::end>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::DescriptorProto_::ReservedRange<Traits>> : std::true_type {};
template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::DescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::ExtensionRangeOptions<Traits>> {
  using T = google::protobuf::ExtensionRangeOptions<Traits>;
  static constexpr auto value = object(
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>,
    "declaration", ::hpp_proto::as_optional_ref<&T::declaration>,
    "features", &T::features,
    "verification", ::hpp_proto::as_optional_ref<&T::verification, google::protobuf::ExtensionRangeOptions_::VerificationState::UNVERIFIED>);
};

template <typename Traits>
struct glz::meta<google::protobuf::ExtensionRangeOptions_::Declaration<Traits>> {
  using T = google::protobuf::ExtensionRangeOptions_::Declaration<Traits>;
  static constexpr auto value = object(
    "number", ::hpp_proto::as_optional_ref<&T::number>,
    "fullName", ::hpp_proto::as_optional_ref<&T::full_name>,
    "type", ::hpp_proto::as_optional_ref<&T::type>,
    "reserved", ::hpp_proto::as_optional_ref<&T::reserved>,
    "repeated", ::hpp_proto::as_optional_ref<&T::repeated>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::ExtensionRangeOptions_::Declaration<Traits>> : std::true_type {};
template <>
struct glz::meta<google::protobuf::ExtensionRangeOptions_::VerificationState> {
  using enum google::protobuf::ExtensionRangeOptions_::VerificationState;
  static constexpr auto value = enumerate(
    "DECLARATION", DECLARATION,
    "UNVERIFIED", UNVERIFIED);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::ExtensionRangeOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::FieldDescriptorProto<Traits>> {
  using T = google::protobuf::FieldDescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "number", ::hpp_proto::as_optional_ref<&T::number>,
    "label", ::hpp_proto::as_optional_ref<&T::label, google::protobuf::FieldDescriptorProto_::Label::LABEL_OPTIONAL>,
    "type", ::hpp_proto::as_optional_ref<&T::type, google::protobuf::FieldDescriptorProto_::Type::TYPE_DOUBLE>,
    "typeName", ::hpp_proto::as_optional_ref<&T::type_name>,
    "extendee", ::hpp_proto::as_optional_ref<&T::extendee>,
    "defaultValue", ::hpp_proto::as_optional_ref<&T::default_value>,
    "oneofIndex", &T::oneof_index,
    "jsonName", ::hpp_proto::as_optional_ref<&T::json_name>,
    "options", &T::options,
    "proto3Optional", ::hpp_proto::as_optional_ref<&T::proto3_optional>);
};

template <>
struct glz::meta<google::protobuf::FieldDescriptorProto_::Type> {
  using enum google::protobuf::FieldDescriptorProto_::Type;
  static constexpr auto value = enumerate(
    "TYPE_DOUBLE", TYPE_DOUBLE,
    "TYPE_FLOAT", TYPE_FLOAT,
    "TYPE_INT64", TYPE_INT64,
    "TYPE_UINT64", TYPE_UINT64,
    "TYPE_INT32", TYPE_INT32,
    "TYPE_FIXED64", TYPE_FIXED64,
    "TYPE_FIXED32", TYPE_FIXED32,
    "TYPE_BOOL", TYPE_BOOL,
    "TYPE_STRING", TYPE_STRING,
    "TYPE_GROUP", TYPE_GROUP,
    "TYPE_MESSAGE", TYPE_MESSAGE,
    "TYPE_BYTES", TYPE_BYTES,
    "TYPE_UINT32", TYPE_UINT32,
    "TYPE_ENUM", TYPE_ENUM,
    "TYPE_SFIXED32", TYPE_SFIXED32,
    "TYPE_SFIXED64", TYPE_SFIXED64,
    "TYPE_SINT32", TYPE_SINT32,
    "TYPE_SINT64", TYPE_SINT64);
};

template <>
struct glz::meta<google::protobuf::FieldDescriptorProto_::Label> {
  using enum google::protobuf::FieldDescriptorProto_::Label;
  static constexpr auto value = enumerate(
    "LABEL_OPTIONAL", LABEL_OPTIONAL,
    "LABEL_REQUIRED", LABEL_REQUIRED,
    "LABEL_REPEATED", LABEL_REPEATED);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FieldDescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::OneofDescriptorProto<Traits>> {
  using T = google::protobuf::OneofDescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "options", &T::options);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::OneofDescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::EnumDescriptorProto<Traits>> {
  using T = google::protobuf::EnumDescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "value", ::hpp_proto::as_optional_ref<&T::value>,
    "options", &T::options,
    "reservedRange", ::hpp_proto::as_optional_ref<&T::reserved_range>,
    "reservedName", ::hpp_proto::as_optional_ref<&T::reserved_name>,
    "visibility", ::hpp_proto::as_optional_ref<&T::visibility, google::protobuf::SymbolVisibility::VISIBILITY_UNSET>);
};

template <typename Traits>
struct glz::meta<google::protobuf::EnumDescriptorProto_::EnumReservedRange<Traits>> {
  using T = google::protobuf::EnumDescriptorProto_::EnumReservedRange<Traits>;
  static constexpr auto value = object(
    "start", ::hpp_proto::as_optional_ref<&T::start>,
    "end", ::hpp_proto::as_optional_ref<&T::end>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::EnumDescriptorProto_::EnumReservedRange<Traits>> : std::true_type {};
template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::EnumDescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::EnumValueDescriptorProto<Traits>> {
  using T = google::protobuf::EnumValueDescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "number", ::hpp_proto::as_optional_ref<&T::number>,
    "options", &T::options);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::EnumValueDescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::ServiceDescriptorProto<Traits>> {
  using T = google::protobuf::ServiceDescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "method", ::hpp_proto::as_optional_ref<&T::method>,
    "options", &T::options);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::ServiceDescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::MethodDescriptorProto<Traits>> {
  using T = google::protobuf::MethodDescriptorProto<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "inputType", ::hpp_proto::as_optional_ref<&T::input_type>,
    "outputType", ::hpp_proto::as_optional_ref<&T::output_type>,
    "options", &T::options,
    "clientStreaming", ::hpp_proto::as_optional_ref<&T::client_streaming, false>,
    "serverStreaming", ::hpp_proto::as_optional_ref<&T::server_streaming, false>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::MethodDescriptorProto<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::FileOptions<Traits>> {
  using T = google::protobuf::FileOptions<Traits>;
  static constexpr auto value = object(
    "javaPackage", ::hpp_proto::as_optional_ref<&T::java_package>,
    "javaOuterClassname", ::hpp_proto::as_optional_ref<&T::java_outer_classname>,
    "javaMultipleFiles", ::hpp_proto::as_optional_ref<&T::java_multiple_files, false>,
    "javaGenerateEqualsAndHash", ::hpp_proto::as_optional_ref<&T::java_generate_equals_and_hash>,
    "javaStringCheckUtf8", ::hpp_proto::as_optional_ref<&T::java_string_check_utf8, false>,
    "optimizeFor", ::hpp_proto::as_optional_ref<&T::optimize_for, google::protobuf::FileOptions_::OptimizeMode::SPEED>,
    "goPackage", ::hpp_proto::as_optional_ref<&T::go_package>,
    "ccGenericServices", ::hpp_proto::as_optional_ref<&T::cc_generic_services, false>,
    "javaGenericServices", ::hpp_proto::as_optional_ref<&T::java_generic_services, false>,
    "pyGenericServices", ::hpp_proto::as_optional_ref<&T::py_generic_services, false>,
    "deprecated", ::hpp_proto::as_optional_ref<&T::deprecated, false>,
    "ccEnableArenas", ::hpp_proto::as_optional_ref<&T::cc_enable_arenas, true>,
    "objcClassPrefix", ::hpp_proto::as_optional_ref<&T::objc_class_prefix>,
    "csharpNamespace", ::hpp_proto::as_optional_ref<&T::csharp_namespace>,
    "swiftPrefix", ::hpp_proto::as_optional_ref<&T::swift_prefix>,
    "phpClassPrefix", ::hpp_proto::as_optional_ref<&T::php_class_prefix>,
    "phpNamespace", ::hpp_proto::as_optional_ref<&T::php_namespace>,
    "phpMetadataNamespace", ::hpp_proto::as_optional_ref<&T::php_metadata_namespace>,
    "rubyPackage", ::hpp_proto::as_optional_ref<&T::ruby_package>,
    "features", &T::features,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <>
struct glz::meta<google::protobuf::FileOptions_::OptimizeMode> {
  using enum google::protobuf::FileOptions_::OptimizeMode;
  static constexpr auto value = enumerate(
    "SPEED", SPEED,
    "CODE_SIZE", CODE_SIZE,
    "LITE_RUNTIME", LITE_RUNTIME);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FileOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::MessageOptions<Traits>> {
  using T = google::protobuf::MessageOptions<Traits>;
  static constexpr auto value = object(
    "messageSetWireFormat", ::hpp_proto::as_optional_ref<&T::message_set_wire_format, false>,
    "noStandardDescriptorAccessor", ::hpp_proto::as_optional_ref<&T::no_standard_descriptor_accessor, false>,
    "deprecated", ::hpp_proto::as_optional_ref<&T::deprecated, false>,
    "mapEntry", ::hpp_proto::as_optional_ref<&T::map_entry>,
    "deprecatedLegacyJsonFieldConflicts", ::hpp_proto::as_optional_ref<&T::deprecated_legacy_json_field_conflicts>,
    "features", &T::features,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::MessageOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::FieldOptions<Traits>> {
  using T = google::protobuf::FieldOptions<Traits>;
  static constexpr auto value = object(
    "ctype", ::hpp_proto::as_optional_ref<&T::ctype, google::protobuf::FieldOptions_::CType::STRING>,
    "packed", &T::packed,
    "jstype", ::hpp_proto::as_optional_ref<&T::jstype, google::protobuf::FieldOptions_::JSType::JS_NORMAL>,
    "lazy", ::hpp_proto::as_optional_ref<&T::lazy, false>,
    "unverifiedLazy", ::hpp_proto::as_optional_ref<&T::unverified_lazy, false>,
    "deprecated", ::hpp_proto::as_optional_ref<&T::deprecated, false>,
    "weak", ::hpp_proto::as_optional_ref<&T::weak, false>,
    "debugRedact", ::hpp_proto::as_optional_ref<&T::debug_redact, false>,
    "retention", ::hpp_proto::as_optional_ref<&T::retention, google::protobuf::FieldOptions_::OptionRetention::RETENTION_UNKNOWN>,
    "targets", ::hpp_proto::as_optional_ref<&T::targets>,
    "editionDefaults", ::hpp_proto::as_optional_ref<&T::edition_defaults>,
    "features", &T::features,
    "featureSupport", &T::feature_support,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <typename Traits>
struct glz::meta<google::protobuf::FieldOptions_::EditionDefault<Traits>> {
  using T = google::protobuf::FieldOptions_::EditionDefault<Traits>;
  static constexpr auto value = object(
    "edition", ::hpp_proto::as_optional_ref<&T::edition, google::protobuf::Edition::EDITION_UNKNOWN>,
    "value", ::hpp_proto::as_optional_ref<&T::value>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FieldOptions_::EditionDefault<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::FieldOptions_::FeatureSupport<Traits>> {
  using T = google::protobuf::FieldOptions_::FeatureSupport<Traits>;
  static constexpr auto value = object(
    "editionIntroduced", ::hpp_proto::as_optional_ref<&T::edition_introduced, google::protobuf::Edition::EDITION_UNKNOWN>,
    "editionDeprecated", ::hpp_proto::as_optional_ref<&T::edition_deprecated, google::protobuf::Edition::EDITION_UNKNOWN>,
    "deprecationWarning", ::hpp_proto::as_optional_ref<&T::deprecation_warning>,
    "editionRemoved", ::hpp_proto::as_optional_ref<&T::edition_removed, google::protobuf::Edition::EDITION_UNKNOWN>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FieldOptions_::FeatureSupport<Traits>> : std::true_type {};
template <>
struct glz::meta<google::protobuf::FieldOptions_::CType> {
  using enum google::protobuf::FieldOptions_::CType;
  static constexpr auto value = enumerate(
    "STRING", STRING,
    "CORD", CORD,
    "STRING_PIECE", STRING_PIECE);
};

template <>
struct glz::meta<google::protobuf::FieldOptions_::JSType> {
  using enum google::protobuf::FieldOptions_::JSType;
  static constexpr auto value = enumerate(
    "JS_NORMAL", JS_NORMAL,
    "JS_STRING", JS_STRING,
    "JS_NUMBER", JS_NUMBER);
};

template <>
struct glz::meta<google::protobuf::FieldOptions_::OptionRetention> {
  using enum google::protobuf::FieldOptions_::OptionRetention;
  static constexpr auto value = enumerate(
    "RETENTION_UNKNOWN", RETENTION_UNKNOWN,
    "RETENTION_RUNTIME", RETENTION_RUNTIME,
    "RETENTION_SOURCE", RETENTION_SOURCE);
};

template <>
struct glz::meta<google::protobuf::FieldOptions_::OptionTargetType> {
  using enum google::protobuf::FieldOptions_::OptionTargetType;
  static constexpr auto value = enumerate(
    "TARGET_TYPE_UNKNOWN", TARGET_TYPE_UNKNOWN,
    "TARGET_TYPE_FILE", TARGET_TYPE_FILE,
    "TARGET_TYPE_EXTENSION_RANGE", TARGET_TYPE_EXTENSION_RANGE,
    "TARGET_TYPE_MESSAGE", TARGET_TYPE_MESSAGE,
    "TARGET_TYPE_FIELD", TARGET_TYPE_FIELD,
    "TARGET_TYPE_ONEOF", TARGET_TYPE_ONEOF,
    "TARGET_TYPE_ENUM", TARGET_TYPE_ENUM,
    "TARGET_TYPE_ENUM_ENTRY", TARGET_TYPE_ENUM_ENTRY,
    "TARGET_TYPE_SERVICE", TARGET_TYPE_SERVICE,
    "TARGET_TYPE_METHOD", TARGET_TYPE_METHOD);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FieldOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::OneofOptions<Traits>> {
  using T = google::protobuf::OneofOptions<Traits>;
  static constexpr auto value = object(
    "features", &T::features,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::OneofOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::EnumOptions<Traits>> {
  using T = google::protobuf::EnumOptions<Traits>;
  static constexpr auto value = object(
    "allowAlias", ::hpp_proto::as_optional_ref<&T::allow_alias>,
    "deprecated", ::hpp_proto::as_optional_ref<&T::deprecated, false>,
    "deprecatedLegacyJsonFieldConflicts", ::hpp_proto::as_optional_ref<&T::deprecated_legacy_json_field_conflicts>,
    "features", &T::features,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::EnumOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::EnumValueOptions<Traits>> {
  using T = google::protobuf::EnumValueOptions<Traits>;
  static constexpr auto value = object(
    "deprecated", ::hpp_proto::as_optional_ref<&T::deprecated, false>,
    "features", &T::features,
    "debugRedact", ::hpp_proto::as_optional_ref<&T::debug_redact, false>,
    "featureSupport", &T::feature_support,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::EnumValueOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::ServiceOptions<Traits>> {
  using T = google::protobuf::ServiceOptions<Traits>;
  static constexpr auto value = object(
    "features", &T::features,
    "deprecated", ::hpp_proto::as_optional_ref<&T::deprecated, false>,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::ServiceOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::MethodOptions<Traits>> {
  using T = google::protobuf::MethodOptions<Traits>;
  static constexpr auto value = object(
    "deprecated", ::hpp_proto::as_optional_ref<&T::deprecated, false>,
    "idempotencyLevel", ::hpp_proto::as_optional_ref<&T::idempotency_level, google::protobuf::MethodOptions_::IdempotencyLevel::IDEMPOTENCY_UNKNOWN>,
    "features", &T::features,
    "uninterpretedOption", ::hpp_proto::as_optional_ref<&T::uninterpreted_option>);
};

template <>
struct glz::meta<google::protobuf::MethodOptions_::IdempotencyLevel> {
  using enum google::protobuf::MethodOptions_::IdempotencyLevel;
  static constexpr auto value = enumerate(
    "IDEMPOTENCY_UNKNOWN", IDEMPOTENCY_UNKNOWN,
    "NO_SIDE_EFFECTS", NO_SIDE_EFFECTS,
    "IDEMPOTENT", IDEMPOTENT);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::MethodOptions<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::UninterpretedOption<Traits>> {
  using T = google::protobuf::UninterpretedOption<Traits>;
  static constexpr auto value = object(
    "name", ::hpp_proto::as_optional_ref<&T::name>,
    "identifierValue", ::hpp_proto::as_optional_ref<&T::identifier_value>,
    "positiveIntValue", ::hpp_proto::as_optional_ref<&T::positive_int_value>,
    "negativeIntValue", ::hpp_proto::as_optional_ref<&T::negative_int_value>,
    "doubleValue", ::hpp_proto::as_optional_ref<&T::double_value>,
    "stringValue", ::hpp_proto::as_optional_ref<&T::string_value>,
    "aggregateValue", ::hpp_proto::as_optional_ref<&T::aggregate_value>);
};

template <typename Traits>
struct glz::meta<google::protobuf::UninterpretedOption_::NamePart<Traits>> {
  using T = google::protobuf::UninterpretedOption_::NamePart<Traits>;
  static constexpr auto value = object(
    "namePart", &T::name_part,
    "isExtension", &T::is_extension);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::UninterpretedOption_::NamePart<Traits>> : std::true_type {};
template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::UninterpretedOption<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::FeatureSet<Traits>> {
  using T = google::protobuf::FeatureSet<Traits>;
  static constexpr auto value = object(
    "fieldPresence", ::hpp_proto::as_optional_ref<&T::field_presence, google::protobuf::FeatureSet_::FieldPresence::FIELD_PRESENCE_UNKNOWN>,
    "enumType", ::hpp_proto::as_optional_ref<&T::enum_type, google::protobuf::FeatureSet_::EnumType::ENUM_TYPE_UNKNOWN>,
    "repeatedFieldEncoding", ::hpp_proto::as_optional_ref<&T::repeated_field_encoding, google::protobuf::FeatureSet_::RepeatedFieldEncoding::REPEATED_FIELD_ENCODING_UNKNOWN>,
    "utf8Validation", ::hpp_proto::as_optional_ref<&T::utf8_validation, google::protobuf::FeatureSet_::Utf8Validation::UTF8_VALIDATION_UNKNOWN>,
    "messageEncoding", ::hpp_proto::as_optional_ref<&T::message_encoding, google::protobuf::FeatureSet_::MessageEncoding::MESSAGE_ENCODING_UNKNOWN>,
    "jsonFormat", ::hpp_proto::as_optional_ref<&T::json_format, google::protobuf::FeatureSet_::JsonFormat::JSON_FORMAT_UNKNOWN>,
    "enforceNamingStyle", ::hpp_proto::as_optional_ref<&T::enforce_naming_style, google::protobuf::FeatureSet_::EnforceNamingStyle::ENFORCE_NAMING_STYLE_UNKNOWN>,
    "defaultSymbolVisibility", ::hpp_proto::as_optional_ref<&T::default_symbol_visibility, google::protobuf::FeatureSet_::VisibilityFeature_::DefaultSymbolVisibility::DEFAULT_SYMBOL_VISIBILITY_UNKNOWN>);
};

template <typename Traits>
struct glz::meta<google::protobuf::FeatureSet_::VisibilityFeature<Traits>> {
  using T = google::protobuf::FeatureSet_::VisibilityFeature<Traits>;
  static constexpr auto value = object(
);
};

template <>
struct glz::meta<google::protobuf::FeatureSet_::VisibilityFeature_::DefaultSymbolVisibility> {
  using enum google::protobuf::FeatureSet_::VisibilityFeature_::DefaultSymbolVisibility;
  static constexpr auto value = enumerate(
    "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", DEFAULT_SYMBOL_VISIBILITY_UNKNOWN,
    "EXPORT_ALL", EXPORT_ALL,
    "EXPORT_TOP_LEVEL", EXPORT_TOP_LEVEL,
    "LOCAL_ALL", LOCAL_ALL,
    "STRICT", STRICT);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FeatureSet_::VisibilityFeature<Traits>> : std::true_type {};
template <>
struct glz::meta<google::protobuf::FeatureSet_::FieldPresence> {
  using enum google::protobuf::FeatureSet_::FieldPresence;
  static constexpr auto value = enumerate(
    "FIELD_PRESENCE_UNKNOWN", FIELD_PRESENCE_UNKNOWN,
    "EXPLICIT", EXPLICIT,
    "IMPLICIT", IMPLICIT,
    "LEGACY_REQUIRED", LEGACY_REQUIRED);
};

template <>
struct glz::meta<google::protobuf::FeatureSet_::EnumType> {
  using enum google::protobuf::FeatureSet_::EnumType;
  static constexpr auto value = enumerate(
    "ENUM_TYPE_UNKNOWN", ENUM_TYPE_UNKNOWN,
    "OPEN", OPEN,
    "CLOSED", CLOSED);
};

template <>
struct glz::meta<google::protobuf::FeatureSet_::RepeatedFieldEncoding> {
  using enum google::protobuf::FeatureSet_::RepeatedFieldEncoding;
  static constexpr auto value = enumerate(
    "REPEATED_FIELD_ENCODING_UNKNOWN", REPEATED_FIELD_ENCODING_UNKNOWN,
    "PACKED", PACKED,
    "EXPANDED", EXPANDED);
};

template <>
struct glz::meta<google::protobuf::FeatureSet_::Utf8Validation> {
  using enum google::protobuf::FeatureSet_::Utf8Validation;
  static constexpr auto value = enumerate(
    "UTF8_VALIDATION_UNKNOWN", UTF8_VALIDATION_UNKNOWN,
    "VERIFY", VERIFY,
    "NONE", NONE);
};

template <>
struct glz::meta<google::protobuf::FeatureSet_::MessageEncoding> {
  using enum google::protobuf::FeatureSet_::MessageEncoding;
  static constexpr auto value = enumerate(
    "MESSAGE_ENCODING_UNKNOWN", MESSAGE_ENCODING_UNKNOWN,
    "LENGTH_PREFIXED", LENGTH_PREFIXED,
    "DELIMITED", DELIMITED);
};

template <>
struct glz::meta<google::protobuf::FeatureSet_::JsonFormat> {
  using enum google::protobuf::FeatureSet_::JsonFormat;
  static constexpr auto value = enumerate(
    "JSON_FORMAT_UNKNOWN", JSON_FORMAT_UNKNOWN,
    "ALLOW", ALLOW,
    "LEGACY_BEST_EFFORT", LEGACY_BEST_EFFORT);
};

template <>
struct glz::meta<google::protobuf::FeatureSet_::EnforceNamingStyle> {
  using enum google::protobuf::FeatureSet_::EnforceNamingStyle;
  static constexpr auto value = enumerate(
    "ENFORCE_NAMING_STYLE_UNKNOWN", ENFORCE_NAMING_STYLE_UNKNOWN,
    "STYLE2024", STYLE2024,
    "STYLE_LEGACY", STYLE_LEGACY);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FeatureSet<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::FeatureSetDefaults<Traits>> {
  using T = google::protobuf::FeatureSetDefaults<Traits>;
  static constexpr auto value = object(
    "defaults", ::hpp_proto::as_optional_ref<&T::defaults>,
    "minimumEdition", ::hpp_proto::as_optional_ref<&T::minimum_edition, google::protobuf::Edition::EDITION_UNKNOWN>,
    "maximumEdition", ::hpp_proto::as_optional_ref<&T::maximum_edition, google::protobuf::Edition::EDITION_UNKNOWN>);
};

template <typename Traits>
struct glz::meta<google::protobuf::FeatureSetDefaults_::FeatureSetEditionDefault<Traits>> {
  using T = google::protobuf::FeatureSetDefaults_::FeatureSetEditionDefault<Traits>;
  static constexpr auto value = object(
    "edition", ::hpp_proto::as_optional_ref<&T::edition, google::protobuf::Edition::EDITION_UNKNOWN>,
    "overridableFeatures", &T::overridable_features,
    "fixedFeatures", &T::fixed_features);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FeatureSetDefaults_::FeatureSetEditionDefault<Traits>> : std::true_type {};
template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::FeatureSetDefaults<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::SourceCodeInfo<Traits>> {
  using T = google::protobuf::SourceCodeInfo<Traits>;
  static constexpr auto value = object(
    "location", ::hpp_proto::as_optional_ref<&T::location>);
};

template <typename Traits>
struct glz::meta<google::protobuf::SourceCodeInfo_::Location<Traits>> {
  using T = google::protobuf::SourceCodeInfo_::Location<Traits>;
  static constexpr auto value = object(
    "path", ::hpp_proto::as_optional_ref<&T::path>,
    "span", ::hpp_proto::as_optional_ref<&T::span>,
    "leadingComments", ::hpp_proto::as_optional_ref<&T::leading_comments>,
    "trailingComments", ::hpp_proto::as_optional_ref<&T::trailing_comments>,
    "leadingDetachedComments", ::hpp_proto::as_optional_ref<&T::leading_detached_comments>);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::SourceCodeInfo_::Location<Traits>> : std::true_type {};
template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::SourceCodeInfo<Traits>> : std::true_type {};
template <typename Traits>
struct glz::meta<google::protobuf::GeneratedCodeInfo<Traits>> {
  using T = google::protobuf::GeneratedCodeInfo<Traits>;
  static constexpr auto value = object(
    "annotation", ::hpp_proto::as_optional_ref<&T::annotation>);
};

template <typename Traits>
struct glz::meta<google::protobuf::GeneratedCodeInfo_::Annotation<Traits>> {
  using T = google::protobuf::GeneratedCodeInfo_::Annotation<Traits>;
  static constexpr auto value = object(
    "path", ::hpp_proto::as_optional_ref<&T::path>,
    "sourceFile", ::hpp_proto::as_optional_ref<&T::source_file>,
    "begin", ::hpp_proto::as_optional_ref<&T::begin>,
    "end", ::hpp_proto::as_optional_ref<&T::end>,
    "semantic", ::hpp_proto::as_optional_ref<&T::semantic, google::protobuf::GeneratedCodeInfo_::Annotation_::Semantic::NONE>);
};

template <>
struct glz::meta<google::protobuf::GeneratedCodeInfo_::Annotation_::Semantic> {
  using enum google::protobuf::GeneratedCodeInfo_::Annotation_::Semantic;
  static constexpr auto value = enumerate(
    "NONE", NONE,
    "SET", SET,
    "ALIAS", ALIAS);
};

template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::GeneratedCodeInfo_::Annotation<Traits>> : std::true_type {};
template <typename Traits>
struct hpp_proto::has_glz<google::protobuf::GeneratedCodeInfo<Traits>> : std::true_type {};
template <>
struct glz::meta<google::protobuf::Edition> {
  using enum google::protobuf::Edition;
  static constexpr auto value = enumerate(
    "EDITION_UNKNOWN", EDITION_UNKNOWN,
    "EDITION_1_TEST_ONLY", EDITION_1_TEST_ONLY,
    "EDITION_2_TEST_ONLY", EDITION_2_TEST_ONLY,
    "EDITION_LEGACY", EDITION_LEGACY,
    "EDITION_PROTO2", EDITION_PROTO2,
    "EDITION_PROTO3", EDITION_PROTO3,
    "EDITION_2023", EDITION_2023,
    "EDITION_2024", EDITION_2024,
    "EDITION_UNSTABLE", EDITION_UNSTABLE,
    "EDITION_99997_TEST_ONLY", EDITION_99997_TEST_ONLY,
    "EDITION_99998_TEST_ONLY", EDITION_99998_TEST_ONLY,
    "EDITION_99999_TEST_ONLY", EDITION_99999_TEST_ONLY,
    "EDITION_MAX", EDITION_MAX);
};

template <>
struct glz::meta<google::protobuf::SymbolVisibility> {
  using enum google::protobuf::SymbolVisibility;
  static constexpr auto value = enumerate(
    "VISIBILITY_UNSET", VISIBILITY_UNSET,
    "VISIBILITY_LOCAL", VISIBILITY_LOCAL,
    "VISIBILITY_EXPORT", VISIBILITY_EXPORT);
};

// clang-format on
